/*
* EBS - RTFS (Real Time File Manager)
*
* Copyright EBS Inc 1987-2003
* All rights reserved.
* This code may not be redistributed in source or linkable object form
* without the consent of its author.
*/
/* drromdsk.c - Rom disk device driver.

Summary

 Description
    Provides a rom drive capability.

    This utility requires romdisk.h which is generated by the mkrom utility

*/
#include "rtfs.h"
#if (INCLUDE_ROMDISK)
/* Include the rom disk data */

#include "drromdsk.h"

static byte *romdisk_block(int driveno, word block)                                       /*__fn__*/
{
	word byte_number;
	RTFS_ARGSUSED_INT(driveno);
    /* Get the page number*/
    byte_number = (word) (block * 512);
    return((byte  *)&romdisk_data[byte_number]);
}


/* BOOLEAN romdisk_io(dword block, void *buffer, word count, BOOLEAN reading)
*
*   Perform io from the romdisk.
*
*   If the reading flag is true copy data from the romdisk (read).
*
*
*/

static BOOLEAN romdisk_io(int driveno, dword block, void  *buffer, word count, BOOLEAN reading) /*__fn__*/
{
    byte  *p;
    int i;
    byte  *pbuffer;

    pbuffer = (byte  *)buffer;

    while (count)
    {
        if (!reading)
            return(FALSE);
        p = romdisk_block(driveno, (word) block);
        if (!p)
            return(FALSE);
        for (i = 0; i < 512; i++)
            *pbuffer++ = *p++;
        count--;
        block++;
    }
    return(TRUE);
}





static int BLK_DEV_RD_blkmedia_io(void  *devhandle, void *pdrive, dword sector, void  *buffer, dword count, BOOLEAN reading);
static int  BLK_DEV_RD_blkmedia_ioctl(void  *handle_or_drive, void *pdrive, int opcode, int iArgs, void *vargs);


#define DEFAULT_NUM_SECTOR_BUFFERS  1
#define DEFAULT_NUM_DIR_BUFFERS     1
#define DEFAULT_NUM_FAT_BUFFERS     1
#define DEFAULT_FATBUFFER_PAGE      1
#define DEFAULT_OPERATING_POLICY    0

/* Set this to 0 to statically declare all buffers and structures, otherwise Rtfs allocates them internally */
#define USE_DYNAMIC_ALLOCATION 0
#if (USE_DYNAMIC_ALLOCATION == 0)

/* Sector buffer provided by BLK_DEV_RD_Romdisk_Mount */
static byte romdisk_sectorbuffer[512];

/* === pparms->blkbuff_memory one for each sector buffer */
static BLKBUFF _blkbuff_memory[DEFAULT_NUM_SECTOR_BUFFERS];
static byte _sector_buffer_memory[DEFAULT_NUM_SECTOR_BUFFERS*512];

/* === pparms->fatbuff_memory one for each FAT page */
static FATBUFF _fatbuff_memory[DEFAULT_NUM_FAT_BUFFERS];
static byte _fat_buffer_memory[DEFAULT_NUM_FAT_BUFFERS*DEFAULT_FATBUFFER_PAGE*512];

#endif

static int BLK_DEV_RD_device_configure_media(struct rtfs_media_insert_args *pmedia_parms, struct rtfs_media_resource_reply *pmedia_config_block, int sector_buffer_required)
{
    RTFS_ARGSUSED_PVOID((void *)pmedia_parms);

    rtfs_print_one_string((byte *)"Attaching rom disk driver at drive N:", PRFLG_NL);

	pmedia_config_block->requested_driveid = (int) ('N'-'A');
	pmedia_config_block->requested_max_partitions =  1;
	pmedia_config_block->use_fixed_drive_id = 1;

	pmedia_config_block->use_dynamic_allocation = USE_DYNAMIC_ALLOCATION;

	if (sector_buffer_required)
	{
		pmedia_config_block->device_sector_buffer_size_bytes = 512;
#if (USE_DYNAMIC_ALLOCATION == 0)
		pmedia_config_block->device_sector_buffer_data  = (void *) &romdisk_sectorbuffer[0];
#endif
	}
	/*	0  if successful
		-1 if unsupported device type
		-2 if out of resources
	*/
	return(0);
}

static int BLK_DEV_RD_device_configure_volume(struct rtfs_volume_resource_request *prequest_block, struct rtfs_volume_resource_reply *pvolume_config_block)
{
	RTFS_ARGSUSED_PVOID((void *)prequest_block);
	/* Initialize necessary fields in pvolume_config_block, fileds that are not explicitly initialized here were
	   set to zero by Rtfs */
    pvolume_config_block->drive_operating_policy 		= DEFAULT_OPERATING_POLICY;
    pvolume_config_block->n_sector_buffers 				= DEFAULT_NUM_SECTOR_BUFFERS;
    pvolume_config_block->n_fat_buffers    				= DEFAULT_NUM_FAT_BUFFERS;
    pvolume_config_block->fat_buffer_page_size_sectors  = DEFAULT_FATBUFFER_PAGE;
#if (USE_DYNAMIC_ALLOCATION == 0)
    pvolume_config_block->blkbuff_memory 				= &_blkbuff_memory[0];
    pvolume_config_block->fatbuff_memory 				= &_fatbuff_memory[0];
    pvolume_config_block->sector_buffer_memory 			= (void *) &_sector_buffer_memory[0];
    pvolume_config_block->fat_buffer_memory 			= (void *) &_fat_buffer_memory[0];
#endif
	pvolume_config_block->use_dynamic_allocation        = USE_DYNAMIC_ALLOCATION;


	return(0);
}

/* Call after Rtfs is intialized to start a ram disk driver on M: */
BOOLEAN BLK_DEV_RD_Romdisk_Mount(void)
{
    /* Set up mount parameters and call Rtfs to mount the device    */
struct rtfs_media_insert_args rtfs_insert_parms;

    /* register with Rtfs File System */
    rtfs_insert_parms.devhandle = (void *) &romdisk_data; /* Not used just a handle */
    rtfs_insert_parms.device_type = 999;	/* not used because private versions of configure and release, but must be non zero */
    rtfs_insert_parms.unit_number = 0;
	rtfs_insert_parms.media_size_sectors = (dword) sizeof(romdisk_data)/512;

	/* Set up HCN values, they are not interpreted, just set to legal value. */
	rtfs_insert_parms.numheads = 1;
    rtfs_insert_parms.secptrk  = 1;
	if (rtfs_insert_parms.media_size_sectors > 1023)
		rtfs_insert_parms.numcyl   = 1023;
	else
		rtfs_insert_parms.numcyl   = rtfs_insert_parms.media_size_sectors;
    rtfs_insert_parms.sector_size_bytes =  (dword) 512;
    rtfs_insert_parms.eraseblock_size_sectors =   0;
    rtfs_insert_parms.write_protect    =          1;

    rtfs_insert_parms.device_io                = BLK_DEV_RD_blkmedia_io;
    rtfs_insert_parms.device_ioctl             = BLK_DEV_RD_blkmedia_ioctl;
    rtfs_insert_parms.device_erase             = 0;
    rtfs_insert_parms.device_configure_media    = BLK_DEV_RD_device_configure_media;
    rtfs_insert_parms.device_configure_volume   = BLK_DEV_RD_device_configure_volume;

    if (pc_rtfs_media_insert(&rtfs_insert_parms) < 0)
    	return(FALSE);
	else
    	return(TRUE);
}

static int BLK_DEV_RD_blkmedia_io(void  *devhandle, void *pdrive, dword sector, void  *buffer, dword count, BOOLEAN reading)
{
    RTFS_ARGSUSED_PVOID((void *)devhandle);
    RTFS_ARGSUSED_PVOID((void *)pdrive);
    return((int)romdisk_io(0 /* driveno */, sector, buffer, (word) count, reading));
}


static int  BLK_DEV_RD_blkmedia_ioctl(void  *handle, void *pdrive, int opcode, int iArgs, void *vargs)
{
    RTFS_ARGSUSED_PVOID(handle);
    RTFS_ARGSUSED_PVOID(pdrive);
    RTFS_ARGSUSED_PVOID(vargs);
    RTFS_ARGSUSED_INT(iArgs);

    switch(opcode)
    {
        case RTFS_IOCTL_FORMAT:
			return(-1);
		case RTFS_IOCTL_INITCACHE:
        case RTFS_IOCTL_FLUSHCACHE:
        default:
			break;
    }
    return(0);
}


#endif /* (INCLUDE_ROMDISK) */

